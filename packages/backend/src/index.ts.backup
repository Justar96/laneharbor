import { Hono } from 'hono'
import { logger } from 'hono/logger'
import { cors } from 'hono/cors'
import { timeout } from 'hono/timeout'
import type { Context } from 'hono'
import { serve } from '@hono/node-server'
import { serveStatic } from '@hono/node-server/serve-static'
import { createServer } from 'node:http'

const app = new Hono()

// CRITICAL: Railway Health Check Endpoint - EXACTLY per Railway docs
// Must return HTTP 200 and accept requests from healthcheck.railway.app
app.get('/health', (c) => {
  // Railway-specific hostname validation
  const host = c.req.header('host') || ''
  const origin = c.req.header('origin') || ''
  const forwardedHost = c.req.header('x-forwarded-host') || ''
  
  // Log the health check request for debugging
  console.log(`[${new Date().toISOString()}] Railway health check:`)
  console.log(`  Host: ${host}`)
  console.log(`  Origin: ${origin}`)
  console.log(`  X-Forwarded-Host: ${forwardedHost}`)
  console.log(`  User-Agent: ${c.req.header('user-agent')}`)
  
  // Railway health checks come from healthcheck.railway.app
  // But also allow internal calls and localhost for development
  const allowedHosts = [
    'healthcheck.railway.app',
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
  ]
  
  // Check if the request is from an allowed host
  const isAllowedHost = allowedHosts.some(allowedHost => 
    host.includes(allowedHost) || 
    forwardedHost.includes(allowedHost) ||
    host.startsWith('localhost:') ||
    host.startsWith('127.0.0.1:') ||
    host.startsWith('0.0.0.0:')
  ) || 
  // Railway internal requests might not have a clear host
  host.includes('railway') ||
  // Allow if no host header (some health checks)
  !host

  if (!isAllowedHost) {
    console.log(`‚ö†Ô∏è  Health check from unallowed host: ${host}`)
  }
  
  // Railway requires exactly HTTP 200 status code
  // No specific response body required - keep it minimal
  c.status(200)
  c.header('Content-Type', 'text/plain')
  c.header('Cache-Control', 'no-store')
  return c.text('OK')
})

// Backup health check endpoint
app.get('/healthz', (c) => {
  console.log(`[${new Date().toISOString()}] Health check (healthz): ${c.req.method} ${c.req.url}`)
  c.status(200)
  c.header('Content-Type', 'text/plain')
  c.header('Cache-Control', 'no-store')
  return c.text('OK')
})

// Support HEAD requests for health checks
app.on('HEAD', '/health', (c) => {
  console.log(`[${new Date().toISOString()}] HEAD health check`)
  c.status(200)
  c.header('Content-Type', 'text/plain')
  c.header('Cache-Control', 'no-store')
  return c.text('')
})

app.on('HEAD', '/healthz', (c) => {
  console.log(`[${new Date().toISOString()}] HEAD healthz`)
  c.status(200)
  c.header('Content-Type', 'text/plain')
  c.header('Cache-Control', 'no-store')
  return c.text('')
})

// Request timeout middleware (30 seconds) - AFTER health checks
app.use('*', timeout(30000))

// CORS middleware with secure defaults
app.use('*', cors({
  origin: process.env.LH_FRONTEND_ORIGIN || '*', // Restrict to frontend origin in production
  allowMethods: ['GET', 'POST', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization', 'Range', 'If-None-Match', 'If-Modified-Since'],
  exposeHeaders: ['Content-Range', 'Accept-Ranges', 'Content-Length', 'X-File-SHA256'],
  credentials: false
}))

// Request logging with enhanced format
app.use('*', logger((message, ...rest) => {
  console.log(`[${new Date().toISOString()}] ${message}`, ...rest)
}))

// Request validation middleware
app.use('*', async (c, next) => {
  // Basic security headers (Railway-compatible)
  c.header('X-Content-Type-Options', 'nosniff')
  c.header('X-XSS-Protection', '1; mode=block')
  c.header('Referrer-Policy', 'strict-origin-when-cross-origin')
  
  // Handle Railway's proxy headers
  const forwardedProto = c.req.header('x-forwarded-proto')
  const forwardedHost = c.req.header('x-forwarded-host')
  
  // Prevent redirect loops on Railway
  if (forwardedProto === 'https' && forwardedHost) {
    c.header('X-Forwarded-Proto', 'https')
    c.header('X-Forwarded-Host', forwardedHost)
  }
  
  // Rate limiting (basic implementation)
  const ip = c.req.header('x-forwarded-for') || 
            c.req.header('x-real-ip') || 
            'unknown'
  
  c.header('X-Rate-Limit-IP', ip)
  
  await next()
})

// Note: Health check endpoints are defined at the top of the file before any middleware

// Detailed status endpoint (for debugging)
app.get('/status', (c: Context) => {
  try {
    const status = {
      service: 'laneharbor-backend',
      status: 'running',
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      uptime: process.uptime(),
      memory: {
        used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
        total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024)
      },
      environment: {
        node_env: process.env.NODE_ENV,
        port: process.env.PORT,
        railway_env: process.env.RAILWAY_ENVIRONMENT
      }
    }

    c.header('Content-Type', 'application/json')
    return c.json(status, 200)
  } catch (error) {
    console.error('Status endpoint error:', error)
    return c.json({ status: 'error', message: 'Status check failed' }, 500)
  }
})

// Initialize main server function
async function initializeServer() {
  // Load dependencies safely - don't crash if they fail
  let env: any = {}
  let registerRoutes: any = null
  let StorageClient: any = null
  let WebSocketService: any = null

  // Load config safely
  try {
    const configModule = await import('./config.js')
    env = configModule.env
    console.log('‚úÖ Config loaded successfully')
  } catch (error) {
    console.error('‚ùå Failed to load config, using defaults:', error)
    env = {
      LH_ENABLE_API: process.env.LH_ENABLE_API !== 'false',
      LH_FRONTEND_ORIGIN: process.env.LH_FRONTEND_ORIGIN,
      PORT: process.env.PORT
    }
  }

  // Load routes safely
  try {
    const routesModule = await import('./routes.js')
    registerRoutes = routesModule.registerRoutes
    console.log('‚úÖ Routes module loaded successfully')
  } catch (error) {
    console.error('‚ùå Failed to load routes module:', error)
  }

  // Load storage client safely
  try {
    const storageModule = await import('./clients/storage.client.js')
    StorageClient = storageModule.StorageClient
    console.log('‚úÖ Storage client module loaded successfully')
  } catch (error) {
    console.error('‚ùå Failed to load storage client module:', error)
  }

  // Load WebSocket service safely
  try {
    const wsModule = await import('./websocket.js')
    WebSocketService = wsModule.WebSocketService
    console.log('‚úÖ WebSocket module loaded successfully')
  } catch (error) {
    console.error('‚ùå Failed to load WebSocket module:', error)
  }

  // Register API routes (conditionally enabled) - but don't block startup
  if (env.LH_ENABLE_API && registerRoutes) {
    try {
      registerRoutes(app)
      console.log('‚úÖ API routes enabled')
    } catch (error) {
      console.error('‚ùå Failed to register API routes:', error)
      console.log('Continuing without API routes to allow health checks...')
    }
  } else {
    console.log('‚ö†Ô∏è  API routes disabled or unavailable')
  }

  return { env, StorageClient, WebSocketService }
}

// API service root endpoint
app.get('/', (c: Context) => {
  return c.json({
    service: 'LaneHarbor Backend API',
    version: '1.0.0',
    endpoints: {
      apps: '/v1/apps',
      health: '/healthz',
      websocket: '/ws'
    }
  });
});

// 404 handler
app.get('*', (c: Context) => {
  return c.json({ error: 'Not Found' }, 404);
});

// Start the server with proper error handling
async function startServer() {
  const port = Number(process.env.PORT || 8787)
  console.log(`üîß Railway Environment Configuration:`)
  console.log(`  PORT: ${port} (Railway required)`)
  console.log(`  RAILWAY_ENVIRONMENT: ${process.env.RAILWAY_ENVIRONMENT || 'not set'}`)
  console.log(`  RAILWAY_HEALTHCHECK_TIMEOUT_SEC: ${process.env.RAILWAY_HEALTHCHECK_TIMEOUT_SEC || 'default (300s)'}`)
  console.log(`  NODE_ENV: ${process.env.NODE_ENV || 'not set'}`)

  // Start the HTTP server immediately for health checks
  const httpServer = createServer()
  
  const server = serve({
    fetch: app.fetch,
    port,
    hostname: '0.0.0.0',
    createServer: () => httpServer
  })

  console.log(`üöÄ LaneHarbor Backend API listening on http://0.0.0.0:${port}`)
  console.log(`üå°Ô∏è  Railway health checks: http://0.0.0.0:${port}/health`)
  console.log(`üìã  Accepts requests from: healthcheck.railway.app`)
  console.log(`‚è±Ô∏è  Health check timeout: ${process.env.RAILWAY_HEALTHCHECK_TIMEOUT_SEC || 300} seconds`)

  // Initialize other services AFTER server starts
  try {
    const { env, StorageClient, WebSocketService } = await initializeServer()
    
    // Initialize storage client (connects to storage service via gRPC)
    // Don't block if storage service is not available
    let storageClient: any = null
    let wsService: any = null

    if (StorageClient) {
      const getStorageServiceConfig = () => {
        const host = process.env.STORAGE_SERVICE_HOST || 'localhost'
        const port = process.env.STORAGE_SERVICE_PORT || '50051'
        
        console.log('üîß Storage Service Configuration:')
        console.log(`  Host: ${host}`)
        console.log(`  Port: ${port}`)
        
        // Railway-specific networking detection
        if (process.env.RAILWAY_ENVIRONMENT) {
          console.log(`üöÇ Railway environment detected: ${process.env.RAILWAY_ENVIRONMENT}`)
          
          // If using localhost in Railway, warn and suggest fix
          if (host === 'localhost') {
            console.warn('‚ö†Ô∏è  WARNING: Using localhost for storage service in Railway!')
            console.warn('   This will likely fail. Please set STORAGE_SERVICE_HOST to:')
            console.warn('   laneharbor-storage.railway.internal')
          }
        }
        
        return { host, port }
      }

      const storageConfig = getStorageServiceConfig()

      try {
        storageClient = new StorageClient(storageConfig.host, storageConfig.port)
        console.log(`üì¶ Storage client initialized for ${storageConfig.host}:${storageConfig.port}`)
        console.log('   (Connection will be established on first use)')
      } catch (error) {
        console.error('Failed to initialize storage client:', error)
        console.log('Storage service will be unavailable, but health checks will still work')
      }
    }

    // Initialize WebSocket service with the HTTP server instance
    if (WebSocketService && storageClient) {
      try {
        wsService = new WebSocketService(httpServer, storageClient)
        console.log(`üîå WebSocket service available at ws://0.0.0.0:${port}/ws`)
      } catch (error) {
        console.error('Failed to initialize WebSocket service:', error)
        console.log('WebSocket service will be unavailable')
      }
    } else {
      console.log('WebSocket service disabled - dependencies unavailable')
    }

    // Add services to app context only for non-health-check routes
    app.use('/v1/*', async (c, next) => {
      (c as any).storageClient = storageClient;
      (c as any).wsService = wsService;
      await next()
    })

    app.use('/ws', async (c, next) => {
      (c as any).storageClient = storageClient;
      (c as any).wsService = wsService;
      await next()
    })

    // Graceful shutdown handlers
    const shutdown = () => {
      console.log('\nShutting down services...')
      if (wsService && typeof wsService.shutdown === 'function') {
        wsService.shutdown()
      }
      if (storageClient && typeof storageClient.close === 'function') {
        storageClient.close()
      }
      process.exit(0)
    }

    process.on('SIGINT', shutdown)
    process.on('SIGTERM', shutdown)

  } catch (error) {
    console.error('‚ùå Failed to initialize services:', error)
    console.log('üå°Ô∏è  Health checks will continue to work')
  }
}

// Start the server
startServer().catch(error => {
  console.error('‚ùå Failed to start server:', error)
  console.log('Server startup failed, but attempting to continue...')
})
